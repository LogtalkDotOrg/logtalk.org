<?xml version="1.0" encoding="iso-8859-1"?>
<?xml-stylesheet type="text/css" href="logtalk.css" ?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head profile="http://www.w3.org/2005/10/profile">
	<meta http-equiv="content-type" content="text/html; charset=iso-8859-1" />
	<title>Logtalk performance</title>
	<link rel="stylesheet" href="logtalk.css" type="text/css" />
	<link rel="shortcut icon" href="/favicon.ico" />
	<meta name="author" lang="pt" content="Paulo Moura"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>

<body>

<div class="header">
<a href="logtalk.html">Home</a> &gt; <a href="documentation.html">Documentation</a> &gt; Performance
</div>

<div class="title">
Logtalk performance
</div>

<p>
This page contains benchmark results for some Prolog compilers. The main goal of this page it to give you some data for comparing predicate performance in plain Prolog and using Logtalk objects. Benchmark results are provided for both static code and dynamic code.
</p>

<div class="topictitle">
Benchmark goals
</div>

<p>
All the tests have been performed using the <code>benchmarks</code> example distributed with Logtalk 3.16.0, using static binding with optional features (including events support) disabled. This provides the most relevant scenario for comparing Logtalk performance with plain Prolog performance. The <code>benchmarks</code> example contains loader files for easily setting up this and other test scenarios (e.g. dynamic binding).
</p>

<div class="subtopictitle">
Static code test goals
</div>

<p>
The <code>benchmarks</code> example provides list length and naive list reverse predicates defined in plain Prolog, in a Prolog module, and in a Logtalk object (predicate definitions are the same in all cases). The following goals are used for the first two benchmark tests:
</p>
<blockquote>
<dl>
	<dt>s11: <code>generate_list(30, List), my_length(List, _)</code></dt>
	<dt>s12: <code>generate_list(30, List), module:mod_length(List, _)</code></dt>
	<dt>s13: <code>generate_list(30, List), object::length(List, _)</code></dt>
</dl>
<dl>
	<dt>s21: <code>generate_list(30, List), my_nrev(List, _)</code></dt>
	<dt>s22: <code>generate_list(30, List), module:mod_nrev(List, _)</code></dt>
	<dt>s23: <code>generate_list(30, List), object::nrev(List, _)</code></dt>
</dl>
</blockquote>
<p>
These benchmark tests use a list of 30 elements as an argument to the list predicates. Increasing the list length may lead to decreasing performance differences between plain Prolog and Logtalk as the list length computation time starts to outweigh the overhead of the message sending mechanism. Likewise, decreasing the list length may lead to increasing performance differences between plain Prolog and Logtalk (up to the point you will be closing on the Logtalk message sending mechanism overhead when compared to plain Prolog predicate calls). However, these tests make use of common library predicates where static binding is easily enabled, eliminating the message sending mechanism overheads. The next two examples deal with graph search:
</p>
<blockquote>
<dl>
	<dt>s31: <code>maze_solve(1, 7, _)</code></dt>
	<dt>s32: <code>module:mod_maze_solve(1, 7, _)</code></dt>
	<dt>s33: <code>maze::solve(1, 7, _)</code></dt>
</dl>
<dl>
	<dt>s41: <code>graph_path(0, 4, _)</code></dt>
	<dt>s42: <code>module:mod_graph_path(0, 4, _)</code></dt>
	<dt>s43: <code>graph::path(0, 4, _)</code></dt>
</dl>
</blockquote>
<p>
When static binding is used, the performance of each set of goals is expected to be similar. The performance of Logtalk can be worse due to the overhead of the extra argument added to each compiled object predicate for carrying execution context information. This overhead depends on the Prolog abstract machine and on the optimizations used to pass unchanged arguments between predicate calls.
</p>

<div class="subtopictitle">
Category test goals
</div>

<p>
Category predicates can be called using either the <code>::/1</code> or the <code>:/1</code> control constructs. When using the <code>:/1</code> control construct, the lookup for both the predicate declaration and the predicate definition begins in <em>this</em> and is restricted to the imported categories. Depending on how the category is compiled, Logtalk may use static binding for <code>:/1</code> calls, providing the same performance level as calls to local object predicates. The following goals are used for the benchmark tests:
</p>
<blockquote>
<dl>
	<dt>c1: <code>leaf::obj_local</code></dt>
	<dt>c2: <code>leaf::ctg_direct</code></dt>
	<dt>c3: <code>leaf::ctg_self</code></dt>
</dl>
</blockquote>
<p>
The <code>obj_local</code> method calls a local object predicate; the performance of such calls is equal or close to plain Prolog. The <code>ctg_direct</code> method uses the <code>:/1</code> control construct to call an imported category predicate. The <code>ctg_self</code> method uses the <code>::/1</code> message sending control construct to call an imported category predicate. While the <code>:/1</code> calls may use static binding, the <code>::/1</code> calls always use dynamic binding and a lookup caching mechanism. Note that the choice between either control construct is not simply a question of performance as the control constructs provide different semantics for calling imported category predicates. All three predicates perform the same computation (generating a list of twenty elements and calculating its length) using local predicates.
</p>

<div class="subtopictitle">
Dynamic code test goals
</div>

<p>
Dynamic code tests include both object database updates and creating and abolishing dynamic objects. The <code>benchmarks</code> example provides an object named <code>database</code>, which defines a set of predicates for testing the Logtalk built-in database methods as described below. The following goals are used for the benchmark tests:
</p>

<blockquote>
<dl>
	<dt>d1: <code>create_object(xpto, [], [], []), abolish_object(xpto)</code></dt>
	<dt>d2: <code>plain_dyndb(_)</code></dt>
	<dt>d3: <code>database::this_dyndb(_)</code></dt>
	<dt>d4: <code>database::self_dyndb(_)</code></dt>
	<dt>d5: <code>database::obj_dyndb(_)</code></dt>
</dl>
</blockquote>
<p>
The first test simply creates and abolishes a (dynamic) object. The remaining tests are used for benchmarking object database updates, comparing with plain Prolog database updates. The <code>*_dyndb</code> tests simply assert (using <code>assertz/1</code>) and retract a clause (using <code>retract/1</code>) of a dynamic predicate with arity one. The <code>plain_dyndb(_)</code> test uses the Prolog built-in database predicates. The other three tests use the Logtalk built-in database methods, using a direct method call (<code>this_dyndb(_)</code>), a call using <code>::/1</code> (<code>self_dyndb(_)</code>), and a call using <code>::/2</code> (<code>obj_dyndb(_)</code>).
</p>

<div class="topictitle">
Static code benchmark results
</div>

<p>
Apple MacBook Pro 15.4" 2.9 GHz Intel Core i7, 16GB RAM, macOS 10.13.4. All results are given in number of calls per second. By default, the benchmark code repeats each goal up to 100000 times in order to get more accurate results. The last columns show the trade-off between plain Prolog and Logtalk. Dynamic binding is never used in the Prolog module tests.
</p>

<div class="subtopictitle">
Static binding (no events support)
</div>

<table>
	<tr>
		<td>Prolog compiler</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s11&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s12&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s13&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;s13/s11&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s21&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s22&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s23&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;s23/s21&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s31&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s32&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s33&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;s33/s31&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s41&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s42&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;s43&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;s43/s41&nbsp;&nbsp;</td>
	</tr>
	<tr>
		<td>B-Prolog 8.1</td>
		<td class="data">2173913</td>
		<td class="data">-</td>
		<td class="data">2631579</td>
		<td class="data">121.1 %</td>
		<td class="data">393701</td>
		<td class="data">-</td>
		<td class="data">362319</td>
		<td class="data">92.0 %</td>
		<td class="data">564972</td>
		<td class="data">-</td>
		<td class="data">469484</td>
		<td class="data">83.1 %</td>
		<td class="data">165017</td>
		<td class="data">-</td>
		<td class="data">133869</td>
		<td class="data">81.1 %</td>
	</tr>
	<tr>
		<td>CxProlog 0.98.2</td>
		<td class="data">340702</td>
		<td class="data">-</td>
		<td class="data">308079</td>
		<td class="data">90.4 %</td>
		<td class="data">63954</td>
		<td class="data">-</td>
		<td class="data">60449</td>
		<td class="data">94.5 %</td>
		<td class="data">117756</td>
		<td class="data">-</td>
		<td class="data">110874</td>
		<td class="data">94.2 %</td>
		<td class="data">30159</td>
		<td class="data">-</td>
		<td class="data">26831</td>
		<td class="data">89.0 %</td>
	</tr>
	<tr>
		<td>ECLiPSe 7.0#41</td>
		<td class="data">2481564</td>
		<td class="data">2003451</td>
		<td class="data">2953668</td>
		<td class="data">119.0 %</td>
		<td class="data">129298</td>
		<td class="data">124091</td>
		<td class="data">134962</td>
		<td class="data">104.4 %</td>
		<td class="data">444949</td>
		<td class="data">417162</td>
		<td class="data">404939</td>
		<td class="data">91.0 %</td>
		<td class="data">92923</td>
		<td class="data">84782</td>
		<td class="data">86275</td>
		<td class="data">92.8 %</td>
	</tr>
	<tr>
		<td>GNU Prolog 1.4.5</td>
		<td class="data">2127660</td>
		<td class="data">-</td>
		<td class="data">2777778</td>
		<td class="data">130.6 %</td>
		<td class="data">140252</td>
		<td class="data">-</td>
		<td class="data">155280</td>
		<td class="data">110.7 %</td>
		<td class="data">153139</td>
		<td class="data">-</td>
		<td class="data">143472</td>
		<td class="data">93.7 %</td>
		<td class="data">41391</td>
		<td class="data">-</td>
		<td class="data">39984</td>
		<td class="data">96.6 %</td>
	</tr>
	<tr>
		<td>Qu-Prolog 10.0</td>
		<td class="data">666667</td>
		<td class="data">-</td>
		<td class="data">588235</td>
		<td class="data">88.2 %</td>
		<td class="data">47170</td>
		<td class="data">-</td>
		<td class="data">46083</td>
		<td class="data">97.7 %</td>
		<td class="data">84746</td>
		<td class="data">-</td>
		<td class="data">81967</td>
		<td class="data">96.7 %</td>
		<td class="data">14144</td>
		<td class="data">-</td>
		<td class="data">13966</td>
		<td class="data">98.7 %</td>
	</tr>
	<tr>
		<td>SICStus Prolog 4.4.1</td>
		<td class="data">20000000</td>
		<td class="data">20000000</td>
		<td class="data">20000000</td>
		<td class="data">100.0 %</td>
		<td class="data">558659</td>
		<td class="data">561798</td>
		<td class="data">552486</td>
		<td class="data">98.9 %</td>
		<td class="data">1075269</td>
		<td class="data">1098901</td>
		<td class="data">1052632</td>
		<td class="data">97.9 %</td>
		<td class="data">278552</td>
		<td class="data">277008</td>
		<td class="data">289855</td>
		<td class="data">104.1 %</td>
	</tr>
	<tr>
		<td>SWI-Prolog 7.7.13 (64 bits)</td>
		<td class="data">772905</td>
		<td class="data">794357</td>
		<td class="data">670767</td>
		<td class="data">86.8 %</td>
		<td class="data">29531</td>
		<td class="data">29173</td>
		<td class="data">27897</td>
		<td class="data">94.5 %</td>
		<td class="data">167705</td>
		<td class="data">169819</td>
		<td class="data">159505</td>
		<td class="data">95.1 %</td>
		<td class="data">30544</td>
		<td class="data">30780</td>
		<td class="data">29901</td>
		<td class="data">97.9 %</td>
	</tr>
	<tr>
		<td>XSB 3.8.0+ (svn, 64 bits)</td>
		<td class="data">2127660</td>
		<td class="data">2631579</td>
		<td class="data">2702703</td>
		<td class="data">127.0 %</td>
		<td class="data">156495</td>
		<td class="data">155521</td>
		<td class="data">154799</td>
		<td class="data">98.9 %</td>
		<td class="data">315457</td>
		<td class="data">315457</td>
		<td class="data">303030</td>
		<td class="data">96.1 %</td>
		<td class="data">86505</td>
		<td class="data">86730</td>
		<td class="data">83752</td>
		<td class="data">96.8 %</td>
	</tr>
	<tr>
		<td>YAP 6.3.5 (git, 64 bits)</td>
		<td class="data">227273</td>
		<td class="data">225225</td>
		<td class="data">236967</td>
		<td class="data">104.3 %</td>
		<td class="data">77882</td>
		<td class="data">78186</td>
		<td class="data">75358</td>
		<td class="data">96.8 %</td>
		<td class="data">213220</td>
		<td class="data">215983</td>
		<td class="data">202020</td>
		<td class="data">94.7 %</td>
		<td class="data">41736</td>
		<td class="data">41615</td>
		<td class="data">40933</td>
		<td class="data">98.1 %</td>
	</tr>
</table>

<div class="topictitle">
Category benchmark results
</div>

<p>
All results are given in number of calls per second. By default, the benchmark code repeats each goal up to 100000 times in order to get more accurate results. The last column shows the trade-off between static binding (<code>c2</code>) and dynamic binding (<code>c3</code>) when calling category predicates.
</p>

<div class="subtopictitle">
Apple MacBook Pro 15.4" 2.9 GHz Intel Core i7, 16GB RAM, macOS 10.13.4.
</div>

<table>
	<tr>
		<td>Prolog compiler</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;c3/c2&nbsp;&nbsp;&nbsp;</td>
	</tr>
	<tr>
		<td>B-Prolog 8.1</td>
		<td class="data">1063830</td>
		<td class="data">1020408</td>
		<td class="data">666667</td>
		<td class="data">65.3 %</td>
	</tr>
	<tr>
		<td>CxProlog 0.98.2</td>
		<td class="data">161343</td>
		<td class="data">160189</td>
		<td class="data">151041</td>
		<td class="data">94.3 %</td>
	</tr>
	<tr>
		<td>ECLiPSe 7.0#41</td>
		<td class="data">961917</td>
		<td class="data">918000</td>
		<td class="data">579907</td>
		<td class="data">63.2 %</td>
	</tr>
	<tr>
		<td>GNU Prolog 1.4.0</td>
		<td class="data">970874</td>
		<td class="data">925926</td>
		<td class="data">645161</td>
		<td class="data">69.7 %</td>
	</tr>
	<tr>
		<td>Qu-Prolog 10.0</td>
		<td class="data">232558</td>
		<td class="data">227273</td>
		<td class="data">212766</td>
		<td class="data">93.6 %</td>
	</tr>
	<tr>
		<td>SICStus Prolog 4.4.1</td>
		<td class="data">3225806</td>
		<td class="data">3030303</td>
		<td class="data">1886792</td>
		<td class="data">62.3 %</td>
	</tr>
	<tr>
		<td>SWI-Prolog 7.7.13 (64 bits)</td>
		<td class="data">253204</td>
		<td class="data">256527</td>
		<td class="data">232163</td>
		<td class="data">90.5 %</td>
	</tr>
	<tr>
		<td>XSB 3.8.0+ (svn, 64 bits)</td>
		<td class="data">1000000</td>
		<td class="data">952381</td>
		<td class="data">800000</td>
		<td class="data">84.0 %</td>
	</tr>
	<tr>
		<td>YAP 6.3.5 (git, 64 bits)</td>
		<td class="data">134953</td>
		<td class="data">132275</td>
		<td class="data">132275</td>
		<td class="data">100.0 %</td>
	</tr>
</table>

<div class="topictitle">
Dynamic code benchmark results
</div>

<p>
All results are given in number of calls per second. By default, the benchmark code repeats each goal up to 100000 times in order to get more accurate results. The last column shows the trade-off between plain Prolog (<code>d2</code>) and Logtalk using static binding (<code>d3</code>).
</p>

<div class="subtopictitle">
Apple MacBook Pro 15.4" 2.9 GHz Intel Core i7, 16GB RAM, macOS 10.13.4.
</div>

<table>
	<tr>
		<td>Prolog compiler</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>
		<td>&nbsp;&nbsp;&nbsp;d3/d2&nbsp;&nbsp;&nbsp;</td>
	</tr>
	<tr>
		<td>B-Prolog 8.1</td>
		<td class="data">10068</td>
		<td class="data">1204819</td>
		<td class="data">1098901</td>
		<td class="data">487805</td>
		<td class="data">1111111</td>
		<td class="data">91.2 %</td>
	</tr>
	<tr>
		<td>CxProlog 0.98.2</td>
		<td class="data">1889</td>
		<td class="data">47158</td>
		<td class="data">29920</td>
		<td class="data">29835</td>
		<td class="data">32284</td>
		<td class="data">63.4 %</td>
	</tr>
	<tr>
		<td>ECLiPSe 7.0#41</td>
		<td class="data">6741</td>
		<td class="data">877645</td>
		<td class="data">837332</td>
		<td class="data">439951</td>
		<td class="data">846068</td>
		<td class="data">95.4 %</td>
	</tr>
	<tr>
		<td>GNU Prolog 1.4.5</td>
		<td class="data">12641</td>
		<td class="data">60423</td>
		<td class="data">65703</td>
		<td class="data">61050</td>
		<td class="data">64893</td>
		<td class="data">108.7 %</td>
	</tr>
	<tr>
		<td>Qu-Prolog 10.0</td>
		<td class="data">1506</td>
		<td class="data">103093</td>
		<td class="data">94340</td>
		<td class="data">84746</td>
		<td class="data">93458</td>
		<td class="data">91.5 %</td>
	</tr>
	<tr>
		<td>SICStus Prolog 4.4.1</td>
		<td class="data">12868</td>
		<td class="data">1666667</td>
		<td class="data">1587302</td>
		<td class="data">1020408</td>
		<td class="data">1562500</td>
		<td class="data">95.2 %</td>
	</tr>
	<tr>
		<td>SWI-Prolog 7.7.13 (64 bits)</td>
		<td class="data">8393</td>
		<td class="data">641363</td>
		<td class="data">611195</td>
		<td class="data">478419</td>
		<td class="data">617894</td>
		<td class="data">95.3 %</td>
	</tr>
	<tr>
		<td>XSB 3.8.0+ (svn, 64 bits)</td>
		<td class="data">2396</td>
		<td class="data">221239</td>
		<td class="data">228833</td>
		<td class="data">198807</td>
		<td class="data">224719</td>
		<td class="data">103.4 %</td>
	</tr>
	<tr>
		<td>YAP 6.3.5 (git, 64 bits)</td>
		<td class="data">2668</td>
		<td class="data">268097</td>
		<td class="data">256410</td>
		<td class="data">219298</td>
		<td class="data">259067</td>
		<td class="data">95.6 %</td>
	</tr>
</table>

<div class="topictitle">
Some unsorted comments
</div>

<ul>
	<li>It's surprisingly difficult to get stable results, specially with some Prolog compilers. One the reasons seems to be the operating-system constant shuffling of processes between the cores.</li>
	<li>Some results are odd, either above the expected maximum (100% of plain Prolog performance) or much lower than what's reasonable to expect. This happens mostly on the most simple benchmark goals. Benchmarks where a more significant amount of work is performed seem to be more (but not complete) immune to these issues.</li>
	<li>All benchmark tests use the default memory allocation for the different program areas. Changing the size of these program areas can have a big impact on the benchmark results (e.g. increasing stack size to avoid wasting time expanding the stack or doing garbage collection).</li>
	<li>Logtalk usually performs better with Prolog compilers with mature virtual machines when compared with Prolog compilers with younger and less optimized virtual machines. The presence, in Logtalk compiled code, of a hidden execution context predicate argument is a particular sensitive point in virtual machines optimization as this extra argument is usually passed unchanged between local predicate calls.</li>
	<li>These are too few and too limited benchmark tests to effectively compare Prolog compiler performance. Notably, some of the Prolog versions used are development versions due to the latest stable version being either too old or containing critical bugs.</li>
	<li>Processor caches sometimes result in tests one order of magnitude better than the results posted above.</li>
	<li>Some of the Prolog built-in predicates used for measuring CPU time are not as accurate as we would like. Despite each benchmark goal being proved by default 100000 times, repeating the tests always show some variation on the final results. Increasing or decreasing the number of repetions may help in getting more stable results.</li>
	<li>In real-life applications, only testing can give you a balanced view on the trade-offs between plain Prolog performance and Logtalk programming features. Nevertheless, and as a general and rough estimate, you can expect a performance penalty between 0% and 10% when using static binding.</li>
</ul>

<p>&nbsp;</p>

<div class="navigation">
<a href="news.html">News</a>&nbsp;&nbsp;<a href="features.html">Features</a>&nbsp;&nbsp;<a href="compatibility.html">Compatibility</a>&nbsp;&nbsp;<a href="documentation.html">Documentation</a>&nbsp;&nbsp;<a href="download.html">Download</a>&nbsp;&nbsp;<a href="https://github.com/LogtalkDotOrg/logtalk3/wiki/">Developers</a>&nbsp;&nbsp;<a href="support.html">Support</a>&nbsp;&nbsp;<a href="http://forums.logtalk.org/">Forums</a>&nbsp;&nbsp;<a href="links.html">Links</a>&nbsp;&nbsp;<a href="http://blog.logtalk.org/">Blog</a>&nbsp;&nbsp;<a href="http://twitter.com/LogtalkDotOrg">Twitter</a>
</div>

<div class="footer">
	<p><span class="left">
		<a href="http://validator.w3.org/check/referer">XHTML</a> + <a href="http://jigsaw.w3.org/css-validator/check/referer">CSS</a><br />
		<a href="mailto:webmaster@logtalk.org">webmaster@logtalk.org</a>
	</span></p>
	<p><span class="right">
		April 30, 2018<br />
		&copy; Paulo Moura, 1998-2018
	</span></p>
	<p class="middle"><a href="http://www.dreamhost.com/donate.cgi?id=7489">web hosting supporting donations</a></p>
</div>

</body>

</html>
